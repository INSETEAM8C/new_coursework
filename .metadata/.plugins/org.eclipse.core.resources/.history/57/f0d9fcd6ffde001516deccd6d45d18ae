import java.awt.Frame;
import java.awt.image.BufferedImageFilter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.Array;
import java.util.Scanner;
import org.apache.commons.*;
import org.apache.commons.lang3.StringUtils;

import java.util.ArrayList;
import java.util.Arrays;

import javax.swing.JOptionPane;

public class add {
	
	boolean trueOrNo = true;
	String ID1;
	String desc1;
	String file11;
	String file21;
	String info1;
	
	// ADD TO INFO FILE
	
	// THINGS THAT THIS NEEDS TO DO IN V2:
	// Fix refresh
	// Add functionality for .2 files, etc. 
	
	
	/** 
	 * Checks to see if the year is the same. If it is not, check to see if the finish date is greater than the start. If not, fail.
	 * Check to see if the month on end is the same as on start. If it isn't, make sure it is greater than the start. Else, fail.
	 * Check to see if the day on end is the same as on start. If it isn't, make sure it is greater. Else, fail.
	 * @param takes values from text boxes to test
	 * @return boolean true or false, which determines if the program should continue
	 * Version 2
	 **/
	public boolean checkForCorrectness(String s, String e, String d){
		
		/**
		 * initialises variables for testing
		 */
		boolean cont = false;
		String[] date1Test = s.split("/");
		String[] date2Test = e.split("/");
		int year1 = Integer.parseInt(date1Test[2]);
		int year2 = Integer.parseInt(date2Test[2]);
		int mon1 = Integer.parseInt(date1Test[1]);
		int mon2 = Integer.parseInt(date2Test[1]);
		int day1 = Integer.parseInt(date1Test[0]);
		int day2 = Integer.parseInt(date2Test[0]);

		/**
		 * Tests inputted fields
		 */
		if (year2 < year1){
			return false; }
		if (year2 > year1){
			return true;
			// Version 2 - checks to see if the duration meets the dates
		}
		if (year2 == year1){
			if(mon2 < mon1){
				return false;}
			else if(mon2 == mon1){
				if(day2 >= day1){
					return true;
				} else if(day2 < day1){
					return false;
			}}else if(mon2 > mon1){
				return true;
				}}
		return false;
	}
	
	public int countNumFullStops(String s){
		int numStops = StringUtils.countMatches(s, ".");
		return numStops;}
	
	/**
	 * Checks to see if the data supplied already exists in the file.
	 */
	public boolean placeCheck(String ID, String desc, String infoString, String file1, String file2) throws IOException{
		Scanner checkNumber = new Scanner(new FileReader(file1));
		ID1 = ID;
		desc1 = desc;
		info1 = infoString;
		file11 = file1;
		file21 = file2;
		
		String toTest;
		String tempTester;
		while(checkNumber.hasNext()){
			tempTester = checkNumber.next();
			toTest = tempTester.replaceAll("[^\\d.]", "");
	        if(!toTest.contains(ID)){
	       	trueOrNo = false;
	       	break;
	        }}
		checkForProgress();
		return trueOrNo;}
	
	public void checkForProgress() throws IOException{
	if(trueOrNo = true){
		addInfo(ID1, desc1, info1, file11, file21);
	}}

	public void addInfo (String ID, String desc, String information, String file1, String file2) throws IOException{
    int filePosCounter = 0;
    String keyInfo =  ID + ", " + desc;
	Scanner checkNumber = new Scanner(new FileReader(file1));
	ArrayList<String> key = new ArrayList<String>();
	ArrayList<String> info = new ArrayList<String>();
	ArrayList<String> valueOfSent = new ArrayList<String>();

	String sentInt = "";
	String sentIntA = "";
	String sentIntB = "";
	
		/**
		 * Initialises variables once checking has completed
		 */
			BufferedReader b1 = new BufferedReader(new FileReader(file1));
			BufferedReader b2 = new BufferedReader(new FileReader(file2));
			String[] identifier = ID.split("\\.");
			int size = identifier.length;
			String numToTest = identifier[identifier.length-1];
			String keyLine;
			String infoLine;
			String testerInt = null;
			String secondInt = null;
			while((keyLine = b1.readLine()) != null){
				key.add(keyLine);
			}
			while((infoLine = b2.readLine()) != null){
				info.add(infoLine);
			}
			
			/**
			 * Gathers sentinel value to test the rest of the items's ID with
			 */
			int numStop = countNumFullStops(ID);
			int Sentsize = identifier.length;
			switch(numStop){
			case 0: sentInt = identifier[Sentsize-1];
					break;
			case 1: sentInt = identifier[Sentsize-2];
					break;
			case 2: sentInt = identifier[Sentsize-3] + "." + identifier[Sentsize-2];
					break;
			case 3: sentInt = identifier[Sentsize-4] + "." + identifier[Sentsize-3] + "." + identifier[Sentsize-2];
					break;
			case 4: sentInt = identifier[Sentsize-5] + "." + identifier[Sentsize-4] + "." + identifier[Sentsize-3] + "." + identifier[Sentsize-2];
					break;
			case 5: sentInt = identifier[Sentsize-6] + "." + identifier[Sentsize-5] + "." + identifier[Sentsize-4] + "." + identifier[Sentsize-3] + "." + identifier[Sentsize-2];
					break;
			}
			
			/**
			 * Compares each item saved in a list to the sentinel variable of the first digit of the ID, having that the numToTest (end digit) is equal to 1
			 */
			if(identifier.length == 1){
					int oneLess = Integer.parseInt(sentInt) +1;
					if(sentInt.equals(oneLess)){
						key.add(filePosCounter, keyInfo);
						info.add(filePosCounter, info1);}
			
			if(numToTest.equals("1") && identifier.length >= 1){
				int test = key.size();
				for(int add=0; add<test; add++){
					filePosCounter += 1;
					String lineToTest = key.get(add);
					String[] identifierFor1 = lineToTest.split(",");
					String IDTest = identifierFor1[0];
					String[] split = IDTest.split("\\.");
					int size1 = split.length;
					int stopsToTest = countNumFullStops(lineToTest);
					switch(stopsToTest){
					case 0: testerInt = split[size1-1];
							break;
					case 1: testerInt = split[size1-2];
							break;
					case 2: testerInt = split[size1-3] + "." + split[size1-2];
							break;
					case 3: testerInt = split[size1-3] + "." + split[size1-2] + "." + split[size1-1];
							break;
					case 4: testerInt = split[size1-4] + "." + split[size1-3] + "." + split[size1-2] + "." + split[size1-1];
							break;
					case 5: testerInt = split[size1-5] + "." + split[size1-4] + "." + split[size1-3] + "." + split[size1-2] + "." + split[size1-1];
							break;
					}
					if(testerInt.equals(sentInt)){
						key.add(filePosCounter, keyInfo);
						info.add(filePosCounter, info1);
						break;}}}
			
			/**
			 * Compares each item saved in a list to the sentinel variable of the first digit of the ID, having that the numToTest (end digit) is greater than 1
			 */
			else if(!numToTest.equals("1") && identifier.length > 1){
				int numStopA = countNumFullStops(ID);
				int SentsizeA = identifier.length;
				switch(numStopA){
				case 1: sentIntA = identifier[SentsizeA-2];
						break;
				}
				switch(numStopA){
				case 1: sentIntB = identifier[SentsizeA-1];
						break;
				}
				int test = key.size();
				for(int add=0; add<test; add++){
					filePosCounter += 1;
					String lineToTest = key.get(add);
					String[] identifierFor1 = lineToTest.split(",");
					String IDTest = identifierFor1[0];
					String[] split = IDTest.split("\\.");
					int size1 = split.length;
					int stopsToTest = countNumFullStops(lineToTest);
					switch(stopsToTest){
					case 0: break;
					case 1: testerInt = split[size1-2];
							break;
					}		
					switch(stopsToTest){
					case 0: break;
					case 1: secondInt = split[size1-1];
							break;
					}
					if(secondInt != null){
					if(Integer.parseInt(testerInt) == Integer.parseInt(sentIntA) && Integer.parseInt(secondInt)+1 == Integer.parseInt(sentIntB)){
						key.add(filePosCounter, keyInfo);
						info.add(filePosCounter, info1);
				}}}}
			
			try{
					BufferedWriter writer = new BufferedWriter(new FileWriter(file1));
					BufferedWriter writer2 = new BufferedWriter(new FileWriter(file2));
					int testW = key.size();
					for(int add1=0; add1<testW; add1++){
						if(add1 != testW-1){
						writer.write(key.get(add1) + "\r\n");
						writer2.write(info.get(add1) + "\r\n");
						} else {
							writer.write(key.get(add1));
							writer2.write(info.get(add1));
						}
					}
					writer.close();
					writer2.close();
					} catch(IOException ex){}}}}